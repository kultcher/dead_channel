Core Run-level Systems:
1. The runner team is positioned toward the left side of the horizontally scrolling Signal timeline. Signals scroll toward the runner team from the left (creating the illusion of the runners moving toward their objective in abstract space). timeline_manager.dg is the source of truth for distance between the runners and Signals. grid_layer.gd draws the grid lines that define the timeline into lanes and individual cells. There are 5 horizontal lanes, and approximately vertical divisions that mark discrete distances. (i.e. if the runners are 3 cells away from a Signal, there will be exactly 3 vertical divisions between them.) 

2. The runner team is, with one exception, always in the center lane. Abstractly, this represents the runners "critical path" - in the game's fantasy, it's not a straight line but a measure of physical and/or temporal distance the runners need to traverse to reach their objective. The other lanes represent spaces outside of the runners direct path but are close enough to still impact it. (i.e. a guard patrolling a hallway near where the runners need to pass, or a camera that is focused elsewhere but may catch the runners in it periphery.) The runner team cannot be commanded directly, except via "slow down" or "speed up" commands (these temporarily live in the timeline_manager). These affect how quickly distance is incremented, and thus how long it takes the Signals to reach the runners.

3. Signals are the primary interaction points. They represent different obstacles, objectives and tools that the player can affect to help their team. SignalData.gd is the base layer, ActiveSignal.gd governs on-screen signals, signal_entity.tscn and .gd govern signal visuals and player input on them, and SignalManager handles creation and state management.
Signals consist of multiple components that govern their behavior and capabilities:
	a. DetectionComponent: Governs the signals effective area of effect. This can be camera vision, motion sensor radius, or a more abstract "contact area" for mobile Signals like guards and drones. Essentially: when the runner team collides with the detection area, a consequence happens.
	b. ResponseComponent (with ResponseEffect): Governs what that consequence is. May be heat Heat gain, damage to the runners, changing the behavior of other signals (such as alerts), or even affecting the player's interface or resources directly.
	c. MobilityComponent: (NYI) Governs movement behaviors for mobile signals like guards and drones. Controls their patrol patterns and alert behaviors.
	d. HackableComponent: Governs the players terminal interactions with the Signal. Routes various terminal commands contextually to determine if the command works and what it does.
	e. PuzzleComponent: Some hackable Signals are locked with a minigame that must be solved before the player can affect the signal. The PuzzleComponent holds the puzzle type and any dynamic modifiers to the puzzle's difficulty.
	f. ICComponent: Intrusion Countermeasures that can have a variety of effects and potentially reach into almost any other system in the game (including eventual campaign-level features like the player's money total). When a player tries to interact with a signal, the ICComponent needs to check if any of it's ICModules need to apply their affect before or after the comamnd is executed.

3a. Subprocesses and Properties: (NYI): Signals can be manipulated at a finer level by affecting specific subprocesses and properties that govern specific behaviors. For example, a camera might have a <stream_video.exe> process and an <FOV> property. The player can affect those specific parts to limit or disable certain behaviors, for a lower heat cost than just disabling the entire Signal. These processes should be dynamically generated from context (i.e. if a Signal has a detection component with vision cone and an FOV variable, that will be surfaced as a subprocess and property.

4. The player can take the following actions on the timeline:
	a. Mouseover a Signal. This automatically begins scanning the signal, which reveals details about that signal in layers (this logic is currently handled in ActiveSignal.gd).
	b. Right-click a signal. This locks scanning to that signal, so the player can continue to scan a signal while doing things elsewhere.
	c. Left-click a signal. This connects the player's terminal window (terminal_window.gd) to that signal's session, so that terminal commands can be executed on that signal (CommandDispatch.gd).
	d. (NYI): Activate a program. Programs are like "spells" that can have a wide variety of effects on different elements of the game world, including but not limited to signals, puzzles and IC. Programs may cost some amount of RAM, a limited but refillable resource.
	e. (NYI): Pause. Pauses the game in a way that pauses the timeline and allows the player to access certain information such as scanned Signal details, but not move the gamestate forward (they can't type commands, complete programs or activate programs.

5. The Terminal Window is the primary gateway to interacting with signals and affecting their behavior or capabilities. The terminal is session based and eventually may include a tabbing features for keeping multiple sessions open. The player has access to 6 commands:
	a. ACCESS: Simplest command, functionally does the same thing as clicking on a Signal on the timeline and connects to that Signal's session. Allows the player to change sessions without moving the mouse.
	b. PROBE: Allows the player to get detailed information about a signal, including it's subprocesses and properties which aren't surfaced in the normal flow.
	c. KILL: Allows the player to directly disable a signal, or one of it's subprocesses. For example, killing a camera's Alert function without disabling it's vision.
	d. SPOOF: (NYI) Allows the player to modify properties, such as changing a camera's FOV so that it's view cone misses the runner team.
	e. LINK: (NYI) Allows the player to link Signals in creative ways. For example, linking one camera's vision area to another's, so that they both look at the same vision area for detection (such that if the runners are passing through camera01's viewcone, but camera01's view is linked to camera02's, no detection will be triggered)

6. Context and the Jargonizer: (NYI) Terminal gameplay is heavily based around providing contextual information for the player. Depending on game progress and difficulty, this information may be obfuscated in different ways or purposely hidden among "noise" (technical-sounding details with no gameplay meaning or impact). When the player connects to a Signal's session and runs commands, the Jargonizer needs to be able to look at what actually exists in the Signal and it's components, and generate flavorful text that makes the player feel like they are interacting with the command-line of a real piece of hardware and it's software.

7. Heat: (NYI) Heat is a difficulty escalation mechanic. Heat generates passively over time (very slowly), and many player actions, Signal responses and IC interact with heat directly. The player also has ways to dump heat, through certain types of signals and programs, though these have not yet been fully designed. Currently heat accumulates and has a visual tracker, but has no consequences.
Once implemented, consequences will include raising a background difficulty modifier, which will cause Signals to spawn with higher-difficulty puzzles, more IC and/or more dangerous behaviors.

8. Window Manager: (NYI) Puzzle windows will eventually need to be moveable by the player. Certain IC may also interact with the player's UI. Other IC may create windows of it's own, such as a Trace IC with a countdown bar illustrating how long the player can keep that terminal session open before there's a consequence.